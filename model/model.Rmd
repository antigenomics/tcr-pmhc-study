---
title: "TCR:pMHC interaction model"

output:
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(dplyr)
library(ggplot2)
library(RColorBrewer)
library(nloptr)
library(reshape2)
library(pROC)
library(bnlearn)
library(stringr)
```

```{r}
df.tcr = read.table("../result/backbone.txt", header = T, sep = "\t") %>%
  mutate(tcr_chain = as.factor(substr(as.character(tcr_v_allele), 1, 3)))

df.ag = read.table("../result/backbone_ag.txt", header = T, sep = "\t")

df.master = read.table("../result/structure.txt", header=T, sep="\t") %>%
  filter(tcr_region %in% c("CDR1", "CDR2", "CDR3")) %>%
  mutate(tcr_chain = as.factor(substr(as.character(tcr_v_allele), 1, 3))) %>%
  droplevels
```

# Backbone

## Overview

Modelling $x_i = f(l, L)$ for $C\alpha$ atoms. CDRs and antigen structures are transformed as follows:

- C terminal residue is used as origin
- Coordinates are rotated so that C-N terminus direction is aligned with X axis 
- YZ projection of the center of mass is aligned with Z axis

First lets have a look at these functions for TCR

```{r}
ggplot(df.tcr, aes(x = pos_tcr / (len_tcr - 1), y = x)) +
  geom_line(aes(group = pdb_id, color = len_tcr), alpha = 0.8) +
  scale_color_gradientn(colors=colorRampPalette(rev(brewer.pal(11, 'Spectral')))(32)) +
  facet_grid(tcr_region~tcr_chain)

ggplot(df.tcr, aes(x = pos_tcr / (len_tcr - 1), y = y)) +
  geom_line(aes(group = pdb_id, color = len_tcr), alpha = 0.8) +
  scale_color_gradientn(colors=colorRampPalette(rev(brewer.pal(11, 'Spectral')))(32)) +
  facet_grid(tcr_region~tcr_chain)

ggplot(df.tcr, aes(x = pos_tcr / (len_tcr - 1), y = z)) +
  geom_line(aes(group = pdb_id, color = len_tcr), alpha = 0.8) +
  scale_color_gradientn(colors=colorRampPalette(rev(brewer.pal(11, 'Spectral')))(32)) +
  facet_grid(tcr_region~tcr_chain)
```

and antigen

```{r}
ggplot(df.ag, aes(x = pos_ag / (len_ag - 1), y = x)) +
  geom_line(aes(group = pdb_id, color = len_ag), alpha = 0.8) +
  scale_color_gradientn(colors=colorRampPalette(rev(brewer.pal(11, 'Spectral')))(32)) +
  facet_grid(.~mhc_type)

ggplot(df.ag, aes(x = pos_ag / (len_ag - 1), y = y)) +
  geom_line(aes(group = pdb_id, color = len_ag), alpha = 0.8) +
  scale_color_gradientn(colors=colorRampPalette(rev(brewer.pal(11, 'Spectral')))(32)) +
  facet_grid(.~mhc_type)

ggplot(df.ag, aes(x = pos_ag / (len_ag - 1), y = z)) +
  geom_line(aes(group = pdb_id, color = len_ag), alpha = 0.8) +
  scale_color_gradientn(colors=colorRampPalette(rev(brewer.pal(11, 'Spectral')))(32)) +
  facet_grid(.~mhc_type)
```

## Fitting XYZ with Beta and linear functions

Functions to fit

```{r}
calc_x = function(l, L, params) {
  H = params[1] + params[2] * L
  a = params[3]
  b = params[4]
  d = params[5] + params[6] * L # distance from C to F/W
  x = l / (L - 1)
  return(x * d + H * x ^ (a - 1) * (1 - x) ^ (b - 1) / beta(a, b))
}

param_ranges_x = data.frame(axis = "x",
                            x0 = c(10, 0.5, 1.5, 1.5, 5, 0.5),
                            lb = c(0, 0, 1.001, 1.001, 0, 0),
                            ub = c(20, 5, 10, 10, 50, 5))

calc_y = function(l, L, params) {
  H = params[1] + params[2] * L
  a1 = params[3]
  b1 = params[4]
  a2 = params[5]
  b2 = params[6]
  x = l / (L - 1)
  return(H * (x ^ (a2 - 1) * (1 - x) ^ (b2 - 1) / beta(a2, b2) - x ^ (a1 - 1) * (1 - x) ^ (b1 - 1) / beta(a1, b1)))
}

param_ranges_y = data.frame(axis = "y",
                            x0 = c(10, 0.5, 2, 5, 5, 2),
                            lb = c(0, 0, 1.001, 1.001, 1.001, 1.001),
                            ub = c(20, 2, 10, 10, 10, 10))

calc_z = function(l, L, params) {
  H = params[1] + params[2] * L
  a = params[3]
  b = params[4]
  x = l / (L - 1)
  return(H * x ^ (a - 1) * (1 - x) ^ (b - 1) / beta(a, b))
}

param_ranges_z = data.frame(axis = "z",
                            x0 = c(10, 0.5, 1.5, 1.5),
                            lb = c(0, 0, 1.001, 1.001),
                            ub = c(20, 2, 10, 10))

params_cdr = rbind(param_ranges_x, param_ranges_y, param_ranges_z)


calc_coord = function(l, L, params, axis) {
   switch(axis,
        x = calc_x(l, L, params),
        y = calc_y(l, L, params),
        z = calc_z(l, L, params))
}
```

### Fitting CDR loops

Optimization goes here

```{r}
params_fitted_tcr = data.frame()

for (t in list(c("CDR1", "CDR2"), "CDR3")) {
  for (a in c("x", "y", "z")) {
    print(paste("Fitting", paste(t), a))
    
    # dplyr::select starting params and bounds
    params_nloptr = params_cdr %>% filter(axis == a)
    
    # prepare data
    df.fit = df.tcr %>% filter(tcr_region %in% t)
    df.fit$value = df.fit[,a]
    df.fit$pos = df.fit$pos_tcr
    df.fit$len = df.fit$len_tcr
    
    # generic objective
    obj = function(params, data) with(data, mean((value - calc_coord(pos, len, params, a))^2))
    
    res = with(params_nloptr,
               nloptr(x0 = x0, lb = lb, ub = ub,
                      eval_f = obj,
                      data = df.fit,
                      opts = list(algorithm = "NLOPT_LN_SBPLX", maxeval = 1e5)))
    
    for (tt in t) {
      solution = data.frame(tcr_region = tt,
                            axis = a,
                            params = res$solution)
      params_fitted_tcr = rbind(params_fitted_tcr, solution)
    }
    
    print(res)
    }
}
```

Check solutions

```{r}
calc_coord_tcr_fitted = function(l, L, tcr_region, axis) {
  t = as.character(tcr_region[1])
  a = as.character(axis[1])
  params = (params_fitted_tcr %>% filter(tcr_region == t, axis == a))$params
  
  calc_coord(l, L, params, a)
}

df.tcr.melt = melt(df.tcr, measure.vars = c("x", "y", "z"))

df.tcr.melt = df.tcr.melt %>%
  group_by(tcr_region, variable) %>%
  mutate(value_fit = calc_coord_tcr_fitted(pos_tcr, len_tcr, tcr_region, variable))
```


```{r}
ggplot(df.tcr.melt %>% filter(variable == "x"), aes(x = pos_tcr / (len_tcr - 1))) +
  geom_line(aes(group = interaction(pdb_id, tcr_chain, tcr_region), y = value), alpha = 0.8) +
  geom_line(aes(group = tcr_region, y = value_fit), color = "red") +
  ylab("x") +
  facet_wrap(~len_tcr)

ggplot(df.tcr.melt %>% filter(variable == "y"), aes(x = pos_tcr / (len_tcr - 1))) +
  geom_line(aes(group = interaction(pdb_id, tcr_chain, tcr_region), y = value), alpha = 0.8) +
  geom_line(aes(group = tcr_region, y = value_fit), color = "red") +
  ylab("y") +
  facet_wrap(~len_tcr)

ggplot(df.tcr.melt %>% filter(variable == "z"), aes(x = pos_tcr / (len_tcr - 1))) +
  geom_line(aes(group = interaction(pdb_id, tcr_chain, tcr_region), y = value), alpha = 0.8) +
  geom_line(aes(group = tcr_region, y = value_fit), color = "red") +
  ylab("z") +
  facet_wrap(~len_tcr)
```

### Fitting antigen peptide

Optimization goes here

```{r}
params_fitted_ag = data.frame()

for (m in c("MHCI", "MHCII")) {
  for (a in c("x", "y", "z")) {
    print(paste("Fitting", m, a))
    
    # dplyr::select starting params and bounds
    params_nloptr = params_cdr %>% filter(axis == a)
    
    # prepare data
    df.fit = df.ag %>% filter(mhc_type %in% m)
    df.fit$value = df.fit[,a]
    df.fit$pos = df.fit$pos_ag
    df.fit$len = df.fit$len_ag
    
    # generic objective
    obj = function(params, data) with(data, mean((value - calc_coord(pos, len, params, a))^2))
    
    res = with(params_nloptr,
               nloptr(x0 = x0, lb = lb, ub = ub,
                      eval_f = obj,
                      data = df.fit,
                      opts = list(algorithm = "NLOPT_LN_SBPLX", maxeval = 1e5)))
    
    solution = data.frame(mhc_type = m,
                          axis = a,
                          params = res$solution)
    params_fitted_ag = rbind(params_fitted_ag, solution)
    
    print(res)
    }
}
```

Check solutions

```{r}
calc_coord_ag_fitted = function(l, L, mhc_type, axis) {
  m = as.character(mhc_type[1])
  a = as.character(axis[1])
  params = (params_fitted_ag %>% filter(mhc_type == m, axis == a))$params
  
  calc_coord(l, L, params, a)
}

df.ag.melt = melt(df.ag, measure.vars = c("x", "y", "z"))

df.ag.melt = df.ag.melt %>%
  group_by(mhc_type, variable) %>%
  mutate(value_fit = calc_coord_ag_fitted(pos_ag, len_ag, mhc_type, variable))
```

```{r}
ggplot(df.ag.melt %>% filter(variable == "x"), aes(x = pos_ag / (len_ag - 1))) +
  geom_line(aes(group = pdb_id, y = value), alpha = 0.8) +
  geom_line(aes(group = mhc_type, y = value_fit), color = "red") +
  ylab("x") +
  facet_wrap(~len_ag)

ggplot(df.ag.melt %>% filter(variable == "y"), aes(x = pos_ag / (len_ag - 1))) +
  geom_line(aes(group = pdb_id, y = value), alpha = 0.8) +
  geom_line(aes(group = mhc_type, y = value_fit), color = "red") +
  ylab("y") +
  facet_wrap(~len_ag)

ggplot(df.ag.melt %>% filter(variable == "z"), aes(x = pos_ag / (len_ag - 1))) +
  geom_line(aes(group = pdb_id, y = value), alpha = 0.8) +
  geom_line(aes(group = mhc_type, y = value_fit), color = "red") +
  ylab("z") +
  facet_wrap(~len_ag)
```

## Optimizing orientation

Parameters of distance function specify separation across Z axis and yaw and pitch rotation

```{r}
calc_dist = function(x_tcr, y_tcr, z_tcr, x_ag, y_ag, z_ag, x_tcr_max, x_ag_max, params) {
  z_tcr = -z_tcr + params[1]
  x_tcr = x_tcr - x_tcr_max / 2
  x_ag = x_ag - x_ag_max / 2
  
  cs1 = cos(params[2])
  ss1 = sin(params[2])
  cs2 = cos(params[3])
  ss2 = sin(params[3])
  
  x_tcr = x_tcr * cs1 - y_tcr * ss1
  y_tcr = x_tcr * ss1 + y_tcr * cs1
  x_tcr = x_tcr * cs2 - z_tcr * ss2
  z_tcr = x_tcr * ss2 + z_tcr * cs2
  
  return(sqrt((x_tcr - x_ag) ^ 2 + (y_tcr - y_ag) ^ 2 + (z_tcr - z_ag) ^ 2))
}
```

Optimization goes here

```{r}
params_fitted_orientation = data.frame()

df.distest.summary = df.master %>%
  group_by(pdb_id, tcr_chain, tcr_region, mhc_type) %>%
  summarize(bad_entity = min(distance_CA) >= 30)

df.distest = merge(df.master, df.distest.summary) %>% filter(!bad_entity)

for (t in c("CDR1", "CDR2", "CDR3")) {
  for (ch in c("TRA", "TRB")) {
    for (m in c("MHCI", "MHCII")) {
      print(paste("Fitting orientation for", t, ch, m))
      
      df.fit = df.distest %>%
        filter(tcr_region == t, tcr_chain == ch, mhc_type == m) %>%
        dplyr::select(pdb_id, pos_tcr, len_tcr, pos_antigen, len_antigen, distance_CA)
      
      df.fit$x_tcr = calc_coord_tcr_fitted(df.fit$pos_tcr, df.fit$len_tcr, t, "x")
      df.fit$y_tcr = calc_coord_tcr_fitted(df.fit$pos_tcr, df.fit$len_tcr, t, "y")
      df.fit$z_tcr = calc_coord_tcr_fitted(df.fit$pos_tcr, df.fit$len_tcr, t, "z")
      
      df.fit$x_ag = calc_coord_ag_fitted(df.fit$pos_antigen, df.fit$len_antigen, m, "x")
      df.fit$y_ag = calc_coord_ag_fitted(df.fit$pos_antigen, df.fit$len_antigen, m, "y")
      df.fit$z_ag = calc_coord_ag_fitted(df.fit$pos_antigen, df.fit$len_antigen, m, "z")
      
      df.fit = df.fit %>%
        group_by(pdb_id) %>%
        mutate(x_tcr_max = max(x_tcr), x_ag_max = max(x_ag))
      
      obj = function(params, data) with(data, mean((1/distance_CA - 
                                                      1/calc_dist(x_tcr, y_tcr, z_tcr,
                                                                x_ag, y_ag, z_ag, 
                                                                x_tcr_max, x_ag_max,
                                                                params))^2))
      
      res = with(params_nloptr,
               nloptr(x0 = c(20, pi/2, 0), lb = c(0, 0, -pi/2), ub = c(100, 2*pi, pi/2),
                      eval_f = obj,
                      data = df.fit,
                      opts = list(algorithm = "NLOPT_LN_SBPLX", maxeval = 1e5)))
      
      sola = res$solution
      sola[2] = sola[2] / pi * 180
      sola[3] = sola[3] / pi * 180
    
      solution = data.frame(mhc_type = m,
                            tcr_chain = ch,
                            tcr_region = t,
                            params = res$solution,
                            params2 = sola,
                            param_name = c("height", "yaw", "pitch"))
      
      params_fitted_orientation = rbind(params_fitted_orientation, solution)
    
      print(res)
    }
  }
}
```

Take a look at fitted values

```{r}
params_fitted_orientation1 = dcast(params_fitted_orientation, mhc_type + tcr_chain + tcr_region ~ param_name, value.var = "params2")
params_fitted_orientation2 = params_fitted_orientation1
params_fitted_orientation2$yaw = params_fitted_orientation2$yaw + 180 
params_fitted_orientation2$pitch = NA 
params_fitted_orientation1 = rbind(params_fitted_orientation1, params_fitted_orientation2)

params_fitted_orientation1$yaw = ifelse(params_fitted_orientation1$yaw > 360, 
                                        params_fitted_orientation1$yaw - 360,
                                        ifelse(params_fitted_orientation1$yaw < 0,
                                               360 + params_fitted_orientation1$yaw,
                                                            params_fitted_orientation1$yaw))
params_fitted_orientation1$pitch = ifelse(params_fitted_orientation1$pitch > 360, 
                                        params_fitted_orientation1$pitch - 360,
                                        ifelse(params_fitted_orientation1$pitch < 0,
                                               360 + params_fitted_orientation1$pitch,
                                                            params_fitted_orientation1$pitch))

ggplot(params_fitted_orientation1, aes(x = yaw, y = 1, color = tcr_region)) +
  geom_bar(stat="identity") +
  geom_point() +
  coord_polar(theta = "x") +
  scale_x_continuous("yaw (rotation wrt Z axis)", breaks=seq(0, 360, by=30), expand=c(0,0), lim=c(0, 360)) +
  facet_grid(mhc_type ~ tcr_chain)

ggplot(params_fitted_orientation1, aes(x = pitch, y = height, color = tcr_region)) +
  geom_bar(stat="identity") +
  geom_point() +
  coord_polar(theta = "x") +
  scale_x_continuous("pitch (rotation wrt Y axis)", breaks=seq(0, 360, by=30), expand=c(0,0), lim=c(0, 360)) +
  facet_grid(mhc_type ~ tcr_chain)
```

General purpose function for computing distances

```{r}
compute_distance_slave = function(pdb_id, pos_tcr, len_tcr, pos_antigen, len_antigen, tcr_chain, tcr_region, mhc_type) {
  tc = as.character(tcr_chain[1])
  tr = as.character(tcr_region[1])
  mt = as.character(mhc_type[1])
  
  x_tcr = calc_coord_tcr_fitted(pos_tcr, len_tcr, tr, "x")
  y_tcr = calc_coord_tcr_fitted(pos_tcr, len_tcr, tr, "y")
  z_tcr = calc_coord_tcr_fitted(pos_tcr, len_tcr, tr, "z")
      
  x_ag = calc_coord_ag_fitted(pos_antigen, len_antigen, mt, "x")
  y_ag = calc_coord_ag_fitted(pos_antigen, len_antigen, mt, "y")
  z_ag = calc_coord_ag_fitted(pos_antigen, len_antigen, mt, "z")
      
  max_x = data.frame(pdb_id, x_tcr, x_ag) %>%
    group_by(pdb_id) %>%
    mutate(x_tcr_max = max(x_tcr), x_ag_max = max(x_ag))
  
  params = (params_fitted_orientation %>%
    filter(tcr_chain == tc & tcr_region == tr & mhc_type == mt))$params
      
  calc_dist(x_tcr, y_tcr, z_tcr, x_ag, y_ag, z_ag, max_x$x_tcr_max, max_x$x_ag_max, params)
}

compute_distances_master = function(data) {
  data %>% 
    group_by(tcr_chain, tcr_region, mhc_type) %>%
    mutate(distance_est = compute_distance_slave(pdb_id, pos_tcr, len_tcr, pos_antigen, len_antigen, tcr_chain, tcr_region, mhc_type))
}

df.distest = compute_distances_master(df.distest)
```

Now lets take a look at overall results

```{r}
ggplot(df.distest, aes(x = as.integer(distance_CA), group = as.integer(distance_CA), y = distance_est)) +
  geom_boxplot() +
  facet_grid(mhc_type~tcr_chain+tcr_region) +
  geom_abline(slope = 1, intercept = 0, color="red", linetype="dashed") +
  scale_x_continuous(limits = c(0, 30)) +
  scale_y_continuous(limits = c(0, 30)) +
  theme_bw()
```

# Contact probabilities

We will use the data frame with estimated distances from previous section. Contacts are defined as amino acid pairs that have interaction energy less than $0$. A simple naive bayes network is used to fit the values.

```{r}
E_NOISE_THRESHOLD = -1

df.bn = df.distest %>%
  mutate(contact = energy < E_NOISE_THRESHOLD, contact_f = as.factor(contact), 
         energy = ifelse(energy > 0, 0, energy),
         aa_pair = as.factor(ifelse(as.character(aa_tcr) < as.character(aa_antigen), 
                                    paste(aa_tcr, aa_antigen, sep = "_"), paste(aa_antigen, aa_tcr, sep = "_")))) %>%
  filter(!is.na(contact)) %>%
  droplevels

df.bn.fc = df.bn %>%
  group_by(pdb_id) %>%
  summarize(few_contacts = sum(contact) < 5) %>%
  filter(few_contacts)

df.bn = df.bn %>%
  filter(!(pdb_id %in% df.bn.fc$pdb_id))
```

Plot distance distribution for contacts and non-contacts:

```{r}
ggplot(df.bn, aes(x = distance_CA, fill = contact)) +
  geom_histogram(binwidth = 1) +
  facet_grid(mhc_type~tcr_chain+tcr_region, scales="free_y") +
  theme_bw()
```

Focus on TCR amino acid

```{r}
ggplot(df.bn, aes(x = distance_est, fill = contact)) +
  geom_histogram(binwidth = 1) +
  facet_wrap(~aa_tcr, scales="free_y") +
  theme_bw()
```

Focus on TCR amino acid, real energy values, color by antigen amino acid

```{r}
ggplot(df.bn, aes(x = distance_est, y = energy, fill = aa_antigen)) +
  geom_point(shape=21) +
  facet_wrap(~aa_tcr) +
  theme_bw() + 
  theme(legend.position="bottom") + guides(fill=guide_legend(nrow=2, byrow=T))

ggplot(df.bn %>% filter(energy < 0 & aa_tcr == "R"), aes(x = distance_est, y = energy)) +
  geom_point(shape=21) +
  facet_wrap(~aa_antigen) +
  theme_bw()
```

## Bayes model

### Fitting the model

Distance discretization, all residues with $d > 21$ automatically get $0$ contact probability. Distances from $5..21$ are put into $2$ angstrom bins

```{r}
ggplot(subset(df.bn, distance_est <= 21), aes(x = pmax(5, distance_est), fill = contact)) +
  geom_histogram(binwidth = 2) +
  facet_grid(contact~., scales = "free_y")
```

Prepare dataset once more

```{r}
df.bn.fit = df.bn %>%
  filter(distance_est <= 21)

df.bn.fit = as.data.frame(df.bn.fit)

df.bn.fit$distance_est_f = as.factor(as.integer(pmax(0, df.bn.fit$distance_est - 5) / 2) + 1)

levels(df.bn.fit$distance_est_f)
```

Our very simple model

```{r}
emp_net = model2network(paste(
  "[contact_f]",
  "[aa_pair|contact_f]",
  "[tcr_region|contact_f]",
  "[distance_est_f|tcr_region:contact_f]",
  sep =""))

graphviz.plot(emp_net)
```

Fit the model

```{r}
df.bn.fit1 = df.bn.fit %>% dplyr::select(aa_pair, 
                                         distance_est_f,
                                         tcr_region,
                                         contact_f)

fit = bn.fit(emp_net,
             df.bn.fit1, method="bayes")

BIC(fit, df.bn.fit1)
```

### Exploring performance

Compute the probabilities and plot the ROC curve

```{r}
res = predict(fit, node="contact_f", method="bayes-lw", 
              data=df.bn.fit1, prob=T)

p = attributes(res)$prob

rocobj = plot.roc(df.bn.fit1[,"contact_f"], p[2,], ci=T)

rocobj
```

By region and chain

```{r}
df.bn.fit$p = p[2,]

df.bn.fit.sum = df.bn.fit %>%
  group_by(pdb_id, tcr_chain, mhc_type, tcr_region) %>%
  summarize(contacts = sum(contact), contacts_est = sum(p))

ggplot(df.bn.fit.sum, aes(x = contacts_est, y = contacts,color=tcr_chain,shape =mhc_type)) +
  geom_point() + geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
  facet_wrap(~tcr_region,scales="free")

summary(lm(contacts~contacts_est, subset(df.bn.fit.sum, tcr_region == "CDR3")))
```

By chain

```{r}
df.bn.fit.sum1 = df.bn.fit %>%
  group_by(pdb_id, tcr_chain, mhc_type) %>%
  summarize(contacts = sum(contact), contacts_est = sum(p))

ggplot(df.bn.fit.sum1, aes(x = contacts_est, y = contacts, color=tcr_chain, shape =mhc_type)) +
  geom_point() + geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed")

summary(lm(contacts~contacts_est, df.bn.fit.sum1))
```

Overall

```{r}
df.bn.fit.sum2 = df.bn.fit %>%
  group_by(pdb_id, mhc_type) %>%
  summarize(contacts = sum(contact), contacts_est = sum(p))

ggplot(df.bn.fit.sum2, aes(x = contacts_est, y = contacts, shape =mhc_type)) +
  geom_point() + geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed")

summary(lm(contacts~contacts_est, df.bn.fit.sum2))
```

### Exploring fitted model

> TODO

# Contact energies

Compute mean energies (for contacts only)

```{r}
df.e = df.bn %>% 
  filter(contact) %>%
  group_by(aa_pair) %>%
  summarize(E = mean(energy))

df.e$aa_tcr = str_split_fixed(df.e$aa_pair, "_", 2)[, 1]
df.e$aa_antigen = str_split_fixed(df.e$aa_pair, "_", 2)[ ,2]

df.e2 = df.e
df.e2$aa_tcr = df.e$aa_antigen
df.e2$aa_antigen = df.e$aa_tcr

df.e = rbind(df.e, df.e2)
df.e2 = NULL

ggplot(df.e, aes(x=aa_tcr, y = aa_antigen, fill=E)) +
  geom_tile() + 
  scale_fill_gradientn(colors=colorRampPalette(rev(brewer.pal(9, 'YlOrRd')))(32)) +
  theme_bw()
```

Merge with BN predictions

```{r}
df.final = merge(df.bn.fit, df.e) %>%
  mutate(pE = p * E)
```

Summarize energies

```{r}
df.final.sum = df.final %>%
  group_by(pdb_id, tcr_chain, mhc_type, tcr_region) %>%
  summarize(E = sum(energy), E_est = sum(pE))

ggplot(df.final.sum, aes(x = E_est, y = E, color=tcr_chain,shape =mhc_type)) +
  geom_point() + geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
  facet_wrap(~tcr_region,scales="free")

summary(lm(E~E_est, subset(df.final.sum, tcr_region == "CDR3")))
```

Example complex

```{r}
df.final.GLC = df.final %>%
  filter(antigen_seq == "GLCTLVAML") %>%
  droplevels()

ggplot(df.final.GLC, aes(x=pos_tcr, y=pos_antigen)) +
  geom_tile(fill=NA) +
  geom_label(aes(label=paste(aa_tcr, aa_antigen, sep=":"), fill = p), cex=1.3) +
  geom_point(aes(color=contact)) +
  scale_x_continuous(breaks=0:20) +
  scale_y_continuous(breaks=0:20) +
  scale_fill_gradient("P", 
                      low="white", high="#045a8d") +
  scale_color_manual(values = c(NA, "red")) +
  facet_grid(tcr_chain ~ tcr_region, scales="free", space="free") +
  theme_bw()

ggplot(df.final.GLC, aes(x=pos_tcr, y=pos_antigen)) +
  geom_tile(fill=NA) +
  geom_label(aes(label=paste(aa_tcr, aa_antigen, sep=":"), fill = pE), cex=1.3) +
  geom_point(aes(color=contact, size = -energy), shape = 21) +
  scale_x_continuous(breaks=0:20) +
  scale_y_continuous(breaks=0:20) +
  scale_fill_gradient("E", 
                      low="#045a8d", high="white") +
  scale_color_manual(values = c(NA, "red")) +
  facet_grid(tcr_chain ~ tcr_region, scales="free", space="free") +
  theme_bw()
```
