---
title: "Local PCM"
output: html_document
---

```{r}
library(data.table)
library(dplyr)
library(ggplot2)
library(mgcv)
library(reshape2)
library(RColorBrewer)
library(stringr)
library(gplots)
library(pROC)
```

## Preprocessing

Load data

```{r}
df = fread("../../preprocessing/output/structure.txt", header=T, sep="\t")[tcr_region %in% c("CDR1", "CDR2", "CDR3")]

df$tcr_v_allele = NULL
df$mhc_a_allele = NULL
df$mhc_b_allele = NULL
df$energy = NULL
df$mhc_type = as.factor(df$mhc_type)
df$tcr_gene = as.factor(df$tcr_gene)
df$tcr_region = as.factor(df$tcr_region)
df$aa_tcr = as.factor(df$aa_tcr)
df$aa_antigen = as.factor(df$aa_antigen)
df$species = as.factor(df$species)
df$pdb_id = as.factor(df$pdb_id)

df$contact = df$distance <= 4.5
df = df[pdb_id != "4p46"] # this one has covlinked peptide

summary(df)
```

Add some annotation

```{r}
df$aa_pair = with(df, 
  as.factor(ifelse(as.character(aa_tcr) < as.character(aa_antigen), paste(aa_tcr, aa_antigen, sep = "_"), paste(aa_antigen, aa_tcr, sep = "_"))))

aa_types = data.frame(
  aa_type = strsplit("aliphatic,aliphatic,aliphatic,aliphatic,basic,basic,basic,sulfur,sulfur,hydroxyl,hydroxyl,acidic,acidic,amide,amide,G,F,P,W,Y", ",")[[1]],
  aa = strsplit("A,I,L,V,R,H,K,C,M,S,T,D,E,N,Q,G,F,P,W,Y", ",")[[1]]
)

df_aa_types = expand.grid(aa_tcr = unique(aa_types$aa), 
                          aa_antigen = unique(aa_types$aa))

colnames(aa_types) = c("aa_type_tcr", "aa_tcr")
df_aa_types = merge(df_aa_types, aa_types)
colnames(aa_types) = c("aa_type_antigen", "aa_antigen")
df_aa_types = merge(df_aa_types, aa_types)
df_aa_types$aa_type_pair = with(df_aa_types, 
  as.factor(ifelse(as.character(aa_type_tcr) < as.character(aa_type_antigen), paste(aa_type_tcr, aa_type_antigen, sep = "_"), paste(aa_type_antigen, aa_type_tcr, sep = "_"))))

df = merge(df, df_aa_types)

colnames(aa_types) = c("aa_type", "aa")
```

Remove bad regions/complexes

```{r}
df.dist.min = df %>%
  group_by(pdb_id, tcr_gene, tcr_region, mhc_type) %>%
  summarize(min_dist = min(distance_CA), mean_dist = mean(distance_CA))

ggplot(df.dist.min, aes(x=pdb_id, y = min_dist, color = paste(tcr_gene, tcr_region))) +
  geom_point() +
  coord_flip() +
  facet_wrap(~mhc_type) + 
  theme_bw()

good_regions = df.dist.min %>% filter(min_dist <= 15) %>%
  select(pdb_id, tcr_gene, tcr_region)

good_regions$good_region = T
 
good_pdb = unique(good_regions$pdb_id)

print(good_pdb)

ggplot(subset(df.dist.min, min_dist<=15), aes(x=pdb_id, y = min_dist, color = paste(tcr_gene, tcr_region))) +
  geom_point() +
  coord_flip() +
  facet_wrap(~mhc_type) + 
  theme_bw()

df = merge(df, good_regions, all.x = T, by = c("pdb_id", "tcr_gene", "tcr_region"))
df$good_region[is.na(df$good_region)] = F
df = subset(df, pdb_id %in% good_pdb)
summary(df)
```

## Distance model

Prepare for computing distances

```{r}
df.dist = df[good_region==T,c("pdb_id", "tcr_gene", "tcr_region", "mhc_type", "pos_tcr", "len_tcr", "pos_antigen", "len_antigen", "distance_CA"), with=F]

compute_positions = function(.df) {
  .df$pos_antigen_c = with(.df, mapply(function(x,y) x + 1 - round(y/2), pos_antigen, len_antigen))
  .df$pos_tcr_c = with(.df, mapply(function(x,y) x + 1 - round(y/2), pos_tcr, len_tcr))
  .df$pos_tcr_e = with(.df, mapply(function(x,y) min(x + 1, y - x - 1), pos_tcr, len_tcr))
  .df$len_tcr = as.numeric(.df$len_tcr)
  .df$len_antigen = as.numeric(.df$len_antigen)  
  .df
}

df.dist = compute_positions(df.dist)

str(df.dist)
```

Generalized additive model builder

```{r}
build_dist_gam = function(.tcr_gene, .tcr_region, .mhc_type,
                          .plot = T) {
  df.dist.test = df.dist[tcr_gene == .tcr_gene & tcr_region == .tcr_region & mhc_type == .mhc_type]
  
  uniq_lengths = length(unique(df.dist.test$len_tcr))
  uniq_tcr_pos = length(unique(df.dist.test$pos_tcr_c))
  uniq_ag_pos = length(unique(df.dist.test$pos_antigen_c))
  
  k1 = min(uniq_lengths - 1, 4)
  k2 = min(uniq_tcr_pos - 1, 7)
  k3 = min(uniq_ag_pos - 1, 7)
  #k2 = min(uniq_tcr_pos - 1, 4)
  #k3 = min(uniq_ag_pos - 1, 4)
  
  if (k1 < 3) {
    .formula = distance_CA ~ te(pos_tcr_c, pos_antigen_c, bs = "ts", 
                              k = c(k2,k3))
  } else {
    .formula = distance_CA ~ te(len_tcr, pos_tcr_c, pos_antigen_c, bs = "ts", 
                              k = c(k1,k2,k3))
  }
  
  distance_mdl <- gam(.formula, data = df.dist.test)
  df.dist.test$distance_CA_pred = predict.gam(distance_mdl, df.dist.test)

  if (.plot) {
    p1 = ggplot(df.dist.test, aes(x=pos_antigen_c, y=pos_tcr_c, fill = distance_CA)) +
      geom_tile(alpha=0.2) +
      geom_vline(xintercept = 0, linetype = "dashed", color = "white") + 
      geom_hline(yintercept = 0, linetype = "dashed", color = "white") + 
      scale_fill_gradientn(colors=colorRampPalette(brewer.pal(11, 'Spectral'))(32), limits=c(0, 30)) +
      facet_grid(len_tcr ~ len_antigen) + 
      theme_dark()
    p2 =ggplot(df.dist.test, aes(x=pos_antigen_c, y=pos_tcr_c, fill = distance_CA_pred)) +
      geom_tile(alpha=0.2) +
      geom_vline(xintercept = 0, linetype = "dashed", color = "white") + 
      geom_hline(yintercept = 0, linetype = "dashed", color = "white") + 
      scale_fill_gradientn(colors=colorRampPalette(brewer.pal(11, 'Spectral'))(32), limits=c(0, 30)) +
      facet_grid(len_tcr ~ len_antigen) + 
      theme_dark()
  } else {
    p1 = NULL
    p2 = NULL
  }
  
  list(plot_real = p1, plot_predicted = p2, model = distance_mdl)
}
```

Try with TRB CDR3 MHCI

```{r}
res = build_dist_gam("TRB", "CDR3", "MHCI")

res$plot_real
res$plot_predicted

summary(res$model)
```

Try with TRA CDR3 MHCI

```{r}
res = build_dist_gam("TRA", "CDR3", "MHCI")

res$plot_real
res$plot_predicted

summary(res$model)
```

Try with TRB CDR3 MHCII

```{r}
res = build_dist_gam("TRB", "CDR3", "MHCII")

res$plot_real
res$plot_predicted

summary(res$model)
```

Try with TRA CDR3 MHCI

```{r}
res = build_dist_gam("TRA", "CDR1", "MHCII")

res$plot_real
res$plot_predicted

summary(res$model)
```

Build all models

```{r}
dist_models = list()

for (tcr_gene in unique(df$tcr_gene)) {
  for (tcr_region in unique(df$tcr_region)) {
    for (mhc_type in unique(df$mhc_type)) {
      name = paste(tcr_gene, tcr_region, mhc_type, sep = "_")
      
      print(name)
    
      dist_models[[name]] = build_dist_gam(tcr_gene, tcr_region, mhc_type, F)$model
    }
  }
}
```

Distance predicting function

```{r}
predict_dist = function(.df, .models = dist_models) {
  .predict = function(tcr_gene, tcr_region, mhc_type,
                      len_tcr, pos_tcr, len_antigen, pos_antigen) {
    pos_antigen_c = mapply(function(x,y) x + 1 - round(y/2), pos_antigen, len_antigen)
    pos_tcr_c = mapply(function(x,y) x + 1 - round(y/2), pos_tcr, len_tcr)
    pos_tcr_e = mapply(function(x,y) min(x + 1, y - x - 1), pos_tcr, len_tcr)
    name = paste(tcr_gene, tcr_region, mhc_type, sep = "_")[1]
    as.vector(predict.gam(.models[[name]], data.frame(len_tcr, pos_antigen_c, pos_tcr_c,pos_tcr_e)))
  }
  
  .df %>%
    group_by(tcr_gene, tcr_region, mhc_type) %>%
    mutate(distance_CA_pred = .predict(tcr_gene, tcr_region, mhc_type,
                      len_tcr, pos_tcr, len_antigen, pos_antigen))
}
```

Compare predicted distances ($\hat{d}_{C_\alpha}$) to real ones ($d_{C_\alpha}$)

```{r}
df.pred = predict_dist(as.data.frame(df))

ggplot(df.pred %>% filter(good_region), aes(x=round(distance_CA), group = round(distance_CA), y=distance_CA_pred)) +
  geom_boxplot(fill = NA) +
  geom_point(aes(color = contact), shape = 21) +
  geom_abline(slope = 1, intercept = 0, color = "blue", linetype = "dashed") +
  #geom_hline(yintercept = 15, color = "green", linetype = "dashed") +
  facet_grid(mhc_type~tcr_gene+tcr_region) +
  scale_x_continuous("True Calpha distance", limits = c(0, 30)) +
  scale_y_continuous("Predicted Calpha distance", limits = c(0, 30)) +
  scale_color_manual("Contact", values = c(NA, "red")) +
  theme_bw()
```

## Contact model

### Raw data

Distance-independent residue-residue contact probability coefficients

```{r}
res0 = glm(contact ~ distance_CA + aa_pair + 0, family = binomial(link = "logit"), 
          data = df.pred)

summary(res0)
```

Plot coefficients, color according to physicochemical properties

```{r}
coef = res0$coefficients
pvalue = coef(summary(res0))[,4]
coef = ifelse(pvalue < 0.05, coef, NA)
names(coef) = str_split_fixed(names(coef), "aa_pair", 2)[,2]

df.aa.coef = data.frame(coef = coef,
                     aa_tcr = str_split_fixed(names(coef), "_", 2)[, 1],
                     aa_antigen = str_split_fixed(names(coef), "_", 2)[ ,2]) %>%
  filter(aa_tcr != "" & aa_antigen != "") %>%
  droplevels

df.aa.coef.rev = df.aa.coef
df.aa.coef.rev$aa_tcr = df.aa.coef$aa_antigen
df.aa.coef.rev$aa_antigen = df.aa.coef$aa_tcr

df.aa.coef = rbind(df.aa.coef, df.aa.coef.rev) %>% unique()

# transform to matrix and plot heatmap.2

aa_pair_mat = dcast(df.aa.coef, aa_tcr ~ aa_antigen, value.var = "coef", fun.aggregate = mean)
rownames(aa_pair_mat) = aa_pair_mat$aa_tcr
aa_pair_mat$aa_tcr = NULL
aa_pair_mat = as.matrix(aa_pair_mat)

aa_colors = brewer.pal(11, "Paired")[as.integer(aa_types$aa_type)]
names(aa_colors) = aa_types$aa

heatmap.2(aa_pair_mat, 
          hclustfun = function(x) hclust(x, method = "ward.D2"),
          RowSideColors = aa_colors[rownames(aa_pair_mat)], 
          ColSideColors = aa_colors[colnames(aa_pair_mat)],
          trace = "none",
          col=colorRampPalette(brewer.pal(9, 'YlGnBu'))(32))
```

> TODO: Kidera

### Amino acid classes and predicted distances

A contact model that operates with $\hat{d}_{C\alpha}$ and uses coefficients corresponding to amino acid pairs grouped by physicochemical properties

```{r}
contact_mdl = glm(contact ~  distance_CA_pred + aa_type_pair + 0, family = binomial(link = "logit"), 
                  data = df.pred)

summary(contact_mdl)
```

Plot resulting coefficients

```{r}
coef = contact_mdl$coefficients
pvalue = coef(summary(contact_mdl))[,4]
coef = ifelse(coef < 0, 0, coef)
names(coef) = str_split_fixed(names(coef), "aa_type_pair", 2)[,2]

df.aa.coef = data.frame(coef = coef,
                     aa_tcr = str_split_fixed(names(coef), "_", 2)[, 1],
                     aa_antigen = str_split_fixed(names(coef), "_", 2)[ ,2]) %>%
  filter(aa_tcr != "" & aa_antigen != "") %>%
  droplevels

df.aa.coef.rev = df.aa.coef
df.aa.coef.rev$aa_tcr = df.aa.coef$aa_antigen
df.aa.coef.rev$aa_antigen = df.aa.coef$aa_tcr

df.aa.coef = rbind(df.aa.coef, df.aa.coef.rev) %>% unique()

# transform to matrix and plot heatmap.2

aa_pair_mat = dcast(df.aa.coef, aa_tcr ~ aa_antigen, value.var = "coef", fun.aggregate = mean)
rownames(aa_pair_mat) = aa_pair_mat$aa_tcr
aa_pair_mat$aa_tcr = NULL
aa_pair_mat = as.matrix(aa_pair_mat)

aa_colors = brewer.pal(11, "Paired")[as.integer(aa_types$aa_type)]
names(aa_colors) = aa_types$aa_type

heatmap.2(aa_pair_mat, 
          hclustfun = function(x) hclust(x, method = "ward.D2"),
          RowSideColors = aa_colors[rownames(aa_pair_mat)], 
          ColSideColors = aa_colors[colnames(aa_pair_mat)],
          trace = "none",
          breaks = seq(2, 8, length.out = 33),
          col=colorRampPalette(brewer.pal(9, 'YlGnBu'))(32))
```

### Accuracy on training set

ROC curves for contact prediction

```{r}
df.pred$p = predict(contact_mdl, df.pred, type="response")

make_roc = function(.df, .name) {
  .rocobj = roc(contact ~ p, .df, ci=T)
  print(.rocobj)
  
  .df.roc = data.frame(spec = .rocobj$specificities, 
                       sens = .rocobj$sensitivities,
                       name = .name)
  
  .df.roc 
}

df.roc = data.frame()

df.roc = rbind(df.roc, make_roc(df.pred %>% filter(distance_CA_pred <= 25), 25))
df.roc = rbind(df.roc, make_roc(df.pred %>% filter(distance_CA_pred <= 20), 20))
df.roc = rbind(df.roc, make_roc(df.pred %>% filter(distance_CA_pred <= 15), 15))

ggplot(df.roc, aes(x=spec, y = sens, group = name, color = paste(name, "A"))) +
  #geom_ribbon(aes(ymin=sens.lo, ymax=sens.hi, group=type), fill="grey", alpha=0.5) +
  geom_line() +
  geom_abline(slope = 1, intercept = 1, linetype = "dashed") +
  #geom_line(aes(y=sens.me, color = type)) +
  scale_x_reverse("Specificity") +
  scale_y_continuous("Sensitivity") +
  scale_color_brewer("Predicted distance threshold", palette = "Set1") +
  theme_bw()
```

Predicted and observed number of contacts

```{r}
df.pred.summary = df.pred %>%
  group_by(pdb_id, mhc_type, tcr_gene, tcr_region, len_tcr) %>%
  summarize(contacts = sum(contact), contacts_pred = sum(p))
ggplot(df.pred.summary, aes(x = contacts, y = contacts_pred, color = paste(tcr_region, tcr_gene), shape = mhc_type)) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  geom_point() +
  facet_wrap(~len_tcr) +
  scale_color_brewer("TCR gene and region", palette = "Paired") +
  scale_shape_discrete("MHC type") +
  xlab("Observed number of contacts") +
  ylab("Predicted number of contacts") +
  theme_bw()

a = aov(contacts ~ contacts_pred + mhc_type + tcr_gene + tcr_region + len_tcr, data=df.pred.summary)
summary(a)
summary(lm(contacts ~ contacts_pred, data=df.pred.summary))

TukeyHSD(a, "tcr_region")
```


## Contact profiles

### Examples from training set

Check for a couple of antigens, GLCTLVAML

```{r}
df.pred.glc = df.pred %>%
  filter(antigen_seq == "GLCTLVAML") %>%
  droplevels()

ggplot(df.pred.glc, aes(x=pos_tcr, y=pos_antigen)) +
  geom_tile(fill=NA) +
  geom_label(aes(label=paste(aa_tcr, aa_antigen, sep=":"), fill = p), cex=1.3) +
  geom_point(aes(color=contact)) +
  scale_x_continuous(breaks=0:20) +
  scale_y_continuous(breaks=0:20) +
  #scale_fill_gradient("P", 
  #                    low="white", high="#045a8d") +
  scale_color_manual(values = c(NA, "red")) +
  scale_fill_gradientn(colors=colorRampPalette(brewer.pal(9, 'YlGnBu'))(32)) +
  facet_grid(tcr_gene ~ tcr_region, scales="free", space="free") +
  theme_bw()
```

and LLFGYPVAV

```{r}
df.pred.llf = df.pred %>%
  filter(antigen_seq == "ILAKFLHWL") %>%
  droplevels()

ggplot(df.pred.llf, aes(x=pos_tcr, y=pos_antigen)) +
  geom_tile(fill=NA) +
  geom_label(aes(label=paste(aa_tcr, aa_antigen, sep=":"), fill = p), cex=1.3) +
  geom_point(aes(color=contact)) +
  scale_x_continuous(breaks=0:20) +
  scale_y_continuous(breaks=0:20) +
  #scale_fill_gradient("P", 
  #                    low="white", high="#045a8d") +
  scale_color_manual(values = c(NA, "red")) +
  scale_fill_gradientn(colors=colorRampPalette(brewer.pal(9, 'YlGnBu'))(32)) +
  facet_grid(tcr_gene ~ tcr_region, scales="free", space="free") +
  theme_bw()
```

### Examples using other data

```{r}
# Requires:
# df_aa_types
# compute_positions()
# predict_dist() + dist_models
# contact_mdl

compute_contact_map = function(mhc_type, tcr_gene, tcr_region, cdr_seq, ag_seq, 
                               tcr_id = "tmp", pmhc_id = "tmp") {
  # Get all TCR residue - AG residue pairs
  .aa_tcr = strsplit(as.character(cdr_seq), "")[[1]]
  .aa_antigen = strsplit(as.character(ag_seq), "")[[1]]
  .df.cdr = data.frame(aa_tcr = .aa_tcr, 
                      pos_tcr = 1:length(.aa_tcr) - 1,
                      len_tcr = length(.aa_tcr),
                      tcr_gene = tcr_gene,
                      tcr_region = tcr_region,
                      tcr_id = tcr_id)
  .df.ag = data.frame(aa_antigen = .aa_antigen, 
                      pos_antigen = 1:length(.aa_antigen) - 1,
                      len_antigen = length(.aa_antigen),
                      mhc_type = mhc_type,
                      pmhc_id = pmhc_id)
  
  .df.pairs = expand.grid(pos_tcr = .df.cdr$pos_tcr, 
                          pos_antigen = .df.ag$pos_antigen)
  
  .df.pairs = merge(.df.pairs, .df.cdr)
  .df.pairs = merge(.df.pairs, .df.ag)
  
  # Annotate by physicochemical properties
  .df.pairs = merge(.df.pairs, df_aa_types) 
  
  # Compute relative coordinates in CDR/FR
  .df.pairs = compute_positions(.df.pairs)
  
  # Predict Calpha distances
  .df.pairs = predict_dist(.df.pairs)
  
  # Predict contact probabilities
  .df.pairs$p = predict(contact_mdl, .df.pairs, type="response")
  .df.pairs$p[is.na(.df.pairs$p)] = 0 # set missing data to 0 (?)
  
  .df.pairs$pE = .df.pairs$p # TODO
  
  as.data.frame(.df.pairs)
}
```

#### Example 1

Testing on data from [http://www.jbc.org/content/289/2/628.full](REF1) - mutated peptide

```{r}
cm.tmp = compute_contact_map("MHCI","TRA","CDR3","CAVDSATSGTYKYIF","ILAKFLHWL", "WT", "WT")
cm.tmp = rbind(cm.tmp, compute_contact_map("MHCI","TRA","CDR3","CAVDSATSGTYKYIF","ILAAFLHWL", "WT", "No binding"))
cm.tmp = rbind(cm.tmp, compute_contact_map("MHCI","TRA","CDR3","CAVDSATSGTYKYIF","GLGGGGGGV", "WT", "Mock"))

print(cm.tmp %>% group_by(pmhc_id) %>% summarize(contacts = sum(p), energy = sum(pE)))

ggplot(cm.tmp, aes(x=pos_tcr, y=pos_antigen)) +
  geom_tile(fill=NA) +
  geom_label(aes(label=paste(aa_tcr, aa_antigen, sep=":"), fill = p), family = "monospace") +
  scale_x_continuous(breaks=0:20) +
  scale_y_continuous(breaks=0:20) +
  scale_fill_gradientn("P", colors=colorRampPalette(brewer.pal(9, 'YlGnBu'))(32)) +
  facet_grid(pmhc_id~., scales="free", space="free") +
  theme_bw()

# ggplot(cm.tmp, aes(x=pos_tcr_c, y=pos_antigen_c)) +
#   geom_tile(fill=NA) +
#   geom_label(aes(label=paste(aa_tcr, aa_antigen, sep=":"), fill = p * energy.mean), cex=2) +
#   scale_x_continuous(breaks=-8:9) +
#   scale_y_continuous(breaks=-5:5) +
#   scale_fill_gradientn("E", colors=rev(colorRampPalette(brewer.pal(9, 'YlOrRd'))(32))) +
#   facet_grid(id~., scales="free", space="free") +
#   theme_bw()
```

#### Example 2

Testing on data from [http://www.nature.com/articles/ncomms6223](REF2) - high affinity Tax mutant

```{r}
cm.tmp = compute_contact_map("MHCI","TRB","CDR3","CASRPGLAGGRPEQYF","LLFGYPVYV","WT")
cm.tmp = rbind(cm.tmp, compute_contact_map("MHCI","TRB","CDR3","CASRPGLMSAQPEQLF","LLFGYPVYV","High affinity (A6-X15)"))

print(cm.tmp %>% group_by(tcr_id) %>% summarize(contacts = sum(p), energy = sum(pE)))

ggplot(cm.tmp, aes(x=pos_tcr, y=pos_antigen)) +
  geom_tile(fill=NA) +
  geom_label(aes(label=paste(aa_tcr, aa_antigen, sep=":"), fill = p), family = "monospace") +
  scale_x_continuous(breaks=0:20) +
  scale_y_continuous(breaks=0:20) +
  scale_fill_gradientn("P", colors=colorRampPalette(brewer.pal(9, 'YlGnBu'))(32)) +
  facet_grid(tcr_id~., scales="free", space="free") +
  theme_bw()
```

### VDJdb example

```{r}
df.vdjdb = read.table("../evaluation/vdjdb-2017-03-18.txt", header = T, sep = "\t") %>%
  filter(gene == "TRB", species == "HomoSapiens", mhc.class == "MHCI") %>%
  select(cdr3, antigen.epitope, mhc.class, v.segm)

df.vdjdb = unique(df.vdjdb)

df.vdjdb.epitopes = (df.vdjdb %>%
  group_by(antigen.epitope, mhc.class) %>%
  summarize(tcr_count = n()) %>%
  arrange(-tcr_count)) %>%
  filter(tcr_count > 100) %>%
  droplevels()

df.vdjdb = df.vdjdb %>%
  filter(antigen.epitope %in% df.vdjdb.epitopes$antigen.epitope) %>%
  droplevels()

str(df.vdjdb)

colnames(df.vdjdb.epitopes) = c("ag_seq", "mhc_type", "tcr_count")

print(df.vdjdb.epitopes)
```

```{r}
colnames(df.vdjdb) = c("cdr_seq", "ag_seq_original", "mhc_type", "v_segm")
df.vdjdb$tcr_gene = "TRB"
df.vdjdb$tcr_region = "CDR3"
str(df.vdjdb)

df.vdjdb.combinations = merge(df.vdjdb, 
                              data.frame(ag_seq = df.vdjdb.epitopes$ag_seq), all =T)

str(df.vdjdb.combinations)
```

```{r}
library(parallel)

compute_contact_sum = function(mhc_type, tcr_gene, tcr_region, cdr_seq, ag_seq) {
  cm = compute_contact_map(mhc_type, tcr_gene, tcr_region, cdr_seq, ag_seq)
  list(p = sum(cm$p), pE = sum(cm$pE))
}

compute_contact_sum_df = function(.df) {
  .res = with(.df, mcmapply(function(a,b,c,d,e) compute_contact_sum(a,b,c,d,e),
           mhc_type, tcr_gene, tcr_region, cdr_seq, ag_seq, mc.cores = 50))
  .df$p = unlist(.res[1,])
  .df$pE = unlist(.res[2,])
  .df
}

# test:
# compute_contact_sum_df(df.vdjdb.combinations[1:5,])
```

```{r}
df.vdjdb.combinations = compute_contact_sum_df(df.vdjdb.combinations)

str(df.vdjdb.combinations)
```

```{r}
ggplot(df.vdjdb.combinations, aes(x=p, color = ag_seq_original == ag_seq)) +
  geom_density() +
  scale_x_continuous(limits=c(0,20)) +
  facet_wrap(~ag_seq)
```